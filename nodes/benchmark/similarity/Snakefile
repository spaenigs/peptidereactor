from sklearn.metrics import confusion_matrix
from glob import glob
from itertools import product, combinations

import pandas as pd
import numpy as np

import os
import yaml


def diversity_score(y_pred_1, y_pred_2):
     lo = len(y_pred_1)
     return 1/lo * sum(np.abs([y_pred_1[i]-y_pred_2[i] for i in range(lo)]))


def phi_score(tn, fp, fn, tp):
    n = tn + fp + fn + tp
    n_11 = tn
    n_1_ = tp + fn
    n__1 = tp + fp
    return (n*n_11 - n_1_*n__1) / np.sqrt(n_1_*n__1 * (n-n_1_) * (n-n__1))


TOKEN = config["token"]

METRICS_GROUP_1_DIR = config["group_1_in"]
METRICS_GROUP_1_CSVS = glob(config["group_1_in"] + "y_pred_cv_*.csv")
NAMES_GROUP_1 = [os.path.basename(p).replace(".csv", "") for p in METRICS_GROUP_1_CSVS]

METRICS_GROUP_2_DIR = config["group_2_in"]
METRICS_GROUP_2_CSVS = glob(config["group_2_in"] + "y_pred_cv_*.csv")
NAMES_GROUP_2 = [os.path.basename(p).replace(".csv", "") for p in METRICS_GROUP_2_CSVS]

if NAMES_GROUP_1 == NAMES_GROUP_2:
    NAMES_G1, NAMES_G2 = zip(*combinations(NAMES_GROUP_1, 2))
else:
    NAMES_G1, NAMES_G2 = zip(*product(NAMES_GROUP_1, NAMES_GROUP_2))

import pydevd_pycharm
pydevd_pycharm.settrace('localhost', port=8889, stdoutToServer=True, stderrToServer=True)

rule all:
     input:
          f"data/temp/{TOKEN}/div.txt",
          f"data/temp/{TOKEN}/phi.txt"

rule compute_similarity:
     input:
          f"{METRICS_GROUP_1_DIR}{{name_g1}}.csv",
          f"{METRICS_GROUP_2_DIR}{{name_g2}}.csv"
     output:
          f"data/temp/{TOKEN}/diversity/{{name_g1}}_vs_{{name_g2}}.yaml",
          f"data/temp/{TOKEN}/phi/{{name_g1}}_vs_{{name_g2}}.yaml"
     run:
          df_pred_1 = pd.read_csv(input[0], index_col=0)
          df_pred_2 = pd.read_csv(input[1], index_col=0)

          div_lst, phi_lst = [], []
          for i in range(50):
              y_pred_1 = df_pred_1.iloc[i, :].dropna()
              y_pred_2 = df_pred_2.iloc[i, :].dropna()
              div_lst += [diversity_score(y_pred_1, y_pred_2)]
              try:
                  tn, fp, fn, tp = confusion_matrix(y_pred_1, y_pred_2).ravel()
              except ValueError:
                  phi_lst += [1.0]
              else:
                  phi_lst += [phi_score(tn, fp, fn, tp)]

          ng1, ng2 = \
            wildcards.name_g1.replace("y_pred_cv_", ""), \
            wildcards.name_g2.replace("y_pred_cv_", "")

          with open(output[0], "w") as f:
               res = float(np.mean(div_lst))
               data = {ng1: {ng2: res}, ng2: {ng1: res}}
               yaml.safe_dump(data, f)

          with open(output[1], "w") as f:
               res = float(np.mean(phi_lst))
               data = {ng1: {ng2: res}, ng2: {ng1: res}}
               yaml.safe_dump(data, f)

rule collect_diversity:
     input:
          expand(f"data/temp/{TOKEN}/diversity/{{name_g1}}_vs_{{name_g2}}.yaml",
                 zip, name_g1=NAMES_G1, name_g2=NAMES_G2)
     output:
          temp(f"data/temp/{TOKEN}/div.txt")
     run:
          df_res = pd.DataFrame(
               columns=set([p.replace("y_pred_cv_", "") for p in NAMES_G1]),
               index=set([p.replace("y_pred_cv_", "") for p in NAMES_G2]))

          for p in list(input):
               with open(p) as f:
                    df_res.update(yaml.safe_load(f))

          # for i, c in zip(df_res.index, df_res.columns):
          #      df_res.loc[i, c] = 0.0

          df_res.to_csv(config["corr_dir_out"] + "diversity.csv")
          shell("touch {output[0]}")

rule collect_phi:
     input:
          expand(f"data/temp/{TOKEN}/phi/{{name_g1}}_vs_{{name_g2}}.yaml",
                 zip, name_g1=NAMES_G1, name_g2=NAMES_G2)
     output:
          temp(f"data/temp/{TOKEN}/phi.txt")
     run:
          df_res = pd.DataFrame(
               columns=set([p.replace("y_pred_cv_", "") for p in NAMES_G1]),
               index=set([p.replace("y_pred_cv_", "") for p in NAMES_G2]))

          for p in list(input):
               with open(p) as f:
                    df_res.update(yaml.safe_load(f))

          df_res.to_csv(config["corr_dir_out"] + "phi.csv")
          shell("touch {output[0]}")