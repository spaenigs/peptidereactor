from glob import glob
from modlamp.core import read_fasta, save_fasta

import os
import sys
import re

sys.path.append(".")

from peptidereactor.workflow_executer \
    import WorkflowExecuter

from nodes.utils.tertiary_structure_search.scripts.dssp_parser \
    import *

CORES = config["cores"]
TOKEN = config["token"]

rule all:
    input:
         config["fasta_out"],
         config["classes_out"],
         config["pdbs_out"],
         config["profiles_out"]

rule blast_search:
    input:
         fasta_in=f"data/temp/{TOKEN}/short_seqs.fasta"
    output:
         pdbs_out=directory(f"data/temp/{TOKEN}/pdbs_blast_search/")
    params:
         snakefile="nodes/utils/tertiary_structure_prediction/blast_search.smk",
         configfile="nodes/utils/tertiary_structure_prediction/blast_search_config.yaml"
    run:
         with WorkflowExecuter(dict(input), dict(output), params.configfile, cores=CORES) as e:
              shell(f"""{e.snakemake} -s {{params.snakefile}} --configfile {{params.configfile}}""")

rule filter_structures_not_found_by_blast:
    input:
         f"data/temp/{TOKEN}/short_seqs.fasta",
         f"data/temp/{TOKEN}/pdbs_blast_search/"
    output:
         f"data/temp/{TOKEN}/blast_search_empty_structures_seqs.fasta"
    run:
         def filter_fasta(fasta_path, pdb_dir):
             seqs, names = read_fasta(fasta_path)
             seqs_to_keep, names_to_keep = [], []
             for seq, name in zip(seqs, names):
                 file_path = \
                     [path for path in glob(pdb_dir + "*.pdb") if name in path][0]
                 if os.path.getsize(file_path) == 0:
                     seqs_to_keep += [seq]
                     names_to_keep += [name]
             return seqs_to_keep, names_to_keep

         seqs, names = \
            filter_fasta(fasta_path=str(input[0]), pdb_dir=str(input[1]))
         save_fasta(str(output), seqs, names)

rule motif_search:
    input:
         fasta_in=f"data/temp/{TOKEN}/blast_search_empty_structures_seqs.fasta"
    output:
         pdbs_out=directory(f"data/temp/{TOKEN}/pdbs_motif_search/")
    params:
         snakefile="nodes/utils/tertiary_structure_prediction/motif_search.smk",
         configfile="nodes/utils/tertiary_structure_prediction/motif_search_config.yaml"
    run:
         with WorkflowExecuter(dict(input), dict(output), params.configfile, cores=CORES) as e:
             shell(f"""{e.snakemake} -s {{params.snakefile}} --configfile {{params.configfile}}""")

rule collect:
    input:
         config["fasta_in"],
         config["classes_in"],
         f"data/temp/{TOKEN}/pdbs_blast_search/",
         f"data/temp/{TOKEN}/pdbs_motif_search/"
    output:
         directory(config["pdbs_out"]),
         config["fasta_out"],
         config["classes_out"]
    run:
         seqs, names = read_fasta(input[0])
         with open(input[1]) as f:
             classes = [l.rstrip for l in f.readlines()]

         seq_tuples = dict((name, tup) for name, tup in zip(names, zip(seqs, classes)))

         paths = \
            glob(input[2] + "*.csv") + \
            glob(input[3] + "*.csv")

         annotated_seqs, annotated_names, annotated_classes = [],[], []
         for pdb_path in paths:
             if os.path.getsize(pdb_path) > 0:
                 seq_name = os.path.basename(pdb_path).replace(".pdb", "")
                 shell(f"cp {pdb_path} {output[0]}")
                 annotated_names += [seq_name]
                 annotated_seqs += [seq_tuples[seq_name][0]]
                 annotated_classes += [seq_tuples[seq_name][1]]

         save_fasta(output[1], annotated_seqs, annotated_names)

         with open(output[2], mode="a") as f:
             for c in annotated_classes:
                 f.write(f"{c}\n")
                 f.flush()

rule generate_secondary_structure_profile:
    input:
         config["pdbs_out"]
    output:
         directory(config["profiles_out"])
    run:
        profile_dir, dssp_dir = output[0], f"data/temp/{TOKEN}/dssps/"
        for pdb_path in glob(f"{input[0]}/*.pdb"):
             pdb_id = re.findall(".*?/(\w+)\.pdb", pdb_path)[0]
             path_to_dssp = f"{dssp_dir}/{pdb_id}.dssp"
             shell(f"mkdssp -i {pdb_path} -o {path_to_dssp}")
             path_to_dis = f"{profile_dir}/{pdb_id}.dis"
             path_to_spXout = f"{profile_dir}/{pdb_id}.spXout"
             generate_disorder_profile(path_to_dssp, path_to_dis)
             generate_spinex_profile(path_to_dssp, path_to_spXout)
